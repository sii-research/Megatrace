diff --git a/src/collectives.cc b/src/collectives.cc
index 571134f..0233290 100644
--- a/src/collectives.cc
+++ b/src/collectives.cc
@@ -9,10 +9,12 @@
 #include "enqueue.h"
 #include "nccl.h"
 
+
 NCCL_API(ncclResult_t, ncclAllGather, const void* sendbuff, void* recvbuff, size_t sendcount,
     ncclDataType_t datatype, ncclComm_t comm, cudaStream_t stream);
 ncclResult_t ncclAllGather(const void* sendbuff, void* recvbuff, size_t sendcount,
     ncclDataType_t datatype, ncclComm_t comm, cudaStream_t stream) {
+  comm->ncclFuncTimes ++;
   // Just pass the size of one message and not the total bytes sent/received.
   constexpr nvtxPayloadSchemaEntry_t AllGatherSchema[] = {
     {0, NVTX_PAYLOAD_ENTRY_TYPE_SIZE, "Message size [bytes]"}
@@ -23,6 +25,7 @@ ncclResult_t ncclAllGather(const void* sendbuff, void* recvbuff, size_t sendcoun
   struct ncclInfo info = { ncclFuncAllGather, "AllGather",
     sendbuff, recvbuff, sendcount, datatype, ncclSum, 0, comm, stream, /* Args */
     ALLGATHER_CHUNKSTEPS, ALLGATHER_SLICESTEPS };
+  info.ncclFuncTimes = comm->ncclFuncTimes;
   NCCLCHECK(ncclEnqueueCheck(&info));
   return ncclSuccess;
 }
@@ -31,6 +34,7 @@ NCCL_API(ncclResult_t, ncclAllReduce, const void* sendbuff, void* recvbuff, size
     ncclDataType_t datatype, ncclRedOp_t op, ncclComm* comm, cudaStream_t stream);
 ncclResult_t ncclAllReduce(const void* sendbuff, void* recvbuff, size_t count,
     ncclDataType_t datatype, ncclRedOp_t op, ncclComm* comm, cudaStream_t stream) {
+  comm->ncclFuncTimes ++;
   struct NvtxParamsAllReduce {
     size_t bytes;
     ncclRedOp_t op;
@@ -47,6 +51,7 @@ ncclResult_t ncclAllReduce(const void* sendbuff, void* recvbuff, size_t count,
   struct ncclInfo info = { ncclFuncAllReduce, "AllReduce",
     sendbuff, recvbuff, count, datatype, op, 0, comm, stream, /* Args */
     ALLREDUCE_CHUNKSTEPS, ALLREDUCE_SLICESTEPS };
+  info.ncclFuncTimes = comm->ncclFuncTimes;
   NCCLCHECK(ncclEnqueueCheck(&info));
   return ncclSuccess;
 }
@@ -55,6 +60,7 @@ NCCL_API(ncclResult_t, ncclBroadcast, const void* sendbuff, void* recvbuff, size
     ncclComm_t comm, cudaStream_t stream);
 ncclResult_t ncclBroadcast(const void* sendbuff, void* recvbuff, size_t count, ncclDataType_t datatype, int root,
     ncclComm_t comm, cudaStream_t stream) {
+  comm->ncclFuncTimes ++;
   struct NvtxParamsBroadcast {
     size_t bytes;
     int root;
@@ -69,6 +75,7 @@ ncclResult_t ncclBroadcast(const void* sendbuff, void* recvbuff, size_t count, n
   struct ncclInfo info = { ncclFuncBroadcast, "Broadcast",
     sendbuff, recvbuff, count, datatype, ncclSum, root, comm, stream, /* Args */
     BROADCAST_CHUNKSTEPS, BROADCAST_SLICESTEPS };
+  info.ncclFuncTimes = comm->ncclFuncTimes;
   NCCLCHECK(ncclEnqueueCheck(&info));
   return ncclSuccess;
 }
@@ -85,6 +92,7 @@ NCCL_API(ncclResult_t, ncclReduce, const void* sendbuff, void* recvbuff, size_t
     ncclDataType_t datatype, ncclRedOp_t op, int root, ncclComm_t comm, cudaStream_t stream);
 ncclResult_t ncclReduce(const void* sendbuff, void* recvbuff, size_t count,
     ncclDataType_t datatype, ncclRedOp_t op, int root, ncclComm_t comm, cudaStream_t stream) {
+  comm->ncclFuncTimes ++;
   struct NvtxParamsReduce {
     size_t bytes;
     int root;
@@ -102,6 +110,7 @@ ncclResult_t ncclReduce(const void* sendbuff, void* recvbuff, size_t count,
   struct ncclInfo info = { ncclFuncReduce, "Reduce",
     sendbuff, recvbuff, count, datatype, op, root, comm, stream, /* Args */
     REDUCE_CHUNKSTEPS, REDUCE_SLICESTEPS };
+  info.ncclFuncTimes = comm->ncclFuncTimes;
   NCCLCHECK(ncclEnqueueCheck(&info));
   return ncclSuccess;
 }
@@ -110,6 +119,7 @@ NCCL_API(ncclResult_t, ncclReduceScatter, const void* sendbuff, void* recvbuff,
     ncclDataType_t datatype, ncclRedOp_t op, ncclComm* comm, cudaStream_t stream);
 ncclResult_t ncclReduceScatter(const void* sendbuff, void* recvbuff, size_t recvcount,
     ncclDataType_t datatype, ncclRedOp_t op, ncclComm* comm, cudaStream_t stream) {
+  comm->ncclFuncTimes ++;
   struct NvtxParamsReduceScatter {
     size_t bytes;
     ncclRedOp_t op;
@@ -125,6 +135,7 @@ ncclResult_t ncclReduceScatter(const void* sendbuff, void* recvbuff, size_t recv
   struct ncclInfo info = { ncclFuncReduceScatter, "ReduceScatter",
     sendbuff, recvbuff, recvcount, datatype, op, 0, comm, stream, /* Args */
     REDUCESCATTER_CHUNKSTEPS, REDUCESCATTER_SLICESTEPS };
+  info.ncclFuncTimes = comm->ncclFuncTimes;
   NCCLCHECK(ncclEnqueueCheck(&info));
   return ncclSuccess;
 }
@@ -142,12 +153,14 @@ NCCL_API(ncclResult_t, ncclSend, const void* sendbuff, size_t count, ncclDataTyp
     ncclComm_t comm, cudaStream_t stream);
 ncclResult_t ncclSend(const void* sendbuff, size_t count, ncclDataType_t datatype, int peer,
     ncclComm_t comm, cudaStream_t stream) {
+  comm->ncclFuncTimes ++;
   NvtxParamsSendRecv payload{count * ncclTypeSize(datatype), peer};
   NVTX3_FUNC_WITH_PARAMS(Send, SendRecvSchema, payload)
 
   struct ncclInfo info = { ncclFuncSend, "Send",
     NULL, (void*)sendbuff, count, datatype, ncclSum, peer, comm, stream, /* Args */
     1, 1 };
+  info.ncclFuncTimes = comm->ncclFuncTimes;
   ncclResult_t ret;
   NCCLCHECK(ncclGroupStart());
   NCCLCHECKGOTO(ncclEnqueueCheck(&info), ret, exit);
@@ -160,12 +173,14 @@ NCCL_API(ncclResult_t, ncclRecv, void* recvbuff, size_t count, ncclDataType_t da
     ncclComm_t comm, cudaStream_t stream);
 ncclResult_t ncclRecv(void* recvbuff, size_t count, ncclDataType_t datatype, int peer,
     ncclComm_t comm, cudaStream_t stream) {
+  comm->ncclFuncTimes ++;
   NvtxParamsSendRecv payload{count * ncclTypeSize(datatype), peer};
   NVTX3_FUNC_WITH_PARAMS(Recv, SendRecvSchema, payload)
 
   struct ncclInfo info = { ncclFuncRecv, "Recv",
     NULL, recvbuff, count, datatype, ncclSum, peer, comm, stream, /* Args */
     1, 1 };
+  info.ncclFuncTimes = comm->ncclFuncTimes;
   ncclResult_t ret;
   NCCLCHECK(ncclGroupStart());
   NCCLCHECKGOTO(ncclEnqueueCheck(&info), ret, exit);
diff --git a/src/device/Makefile b/src/device/Makefile
index 1e9311f..f790b3d 100644
--- a/src/device/Makefile
+++ b/src/device/Makefile
@@ -56,7 +56,7 @@ $(OBJDIR)/gensrc: generate.py
 	  (bar='!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'; \
 	   printf "\n$${bar}\nERROR: Building NCCL requires a Python 3 installation invokable as 'python3'.\n$${bar}\n\n" 1>&2; \
 	   exit 1)) \
-	&& ./generate.py $@ "$(ONLY_FUNCS)"
+	&& python3 ./generate.py $@ "$(ONLY_FUNCS)"
 else
 # Case if the <gensrc> directory is pre-generated and checked in the repo as ./gen:
 $(OBJDIR)/gensrc:
diff --git a/src/enqueue.cc b/src/enqueue.cc
index af57f1b..4580cd0 100644
--- a/src/enqueue.cc
+++ b/src/enqueue.cc
@@ -15,6 +15,15 @@
 #include <cassert>
 #include <cstring> // std::memcpy
 #include <cinttypes> // PRIx64
+extern ncclResult_t parseList(const char *str, const char *elems[], int nelems, int *list);
+#include <unistd.h>
+#include <cstdlib>
+#include <time.h>
+#define MEGA_CC
+#include "ring_log.h"
+extern const int nccl_megatrace_enable;
+
+
 
 NCCL_PARAM(L1SharedMemoryCarveout, "L1_SHARED_MEMORY_CARVEOUT", 0);
 
@@ -510,7 +519,8 @@ NCCL_PARAM(P2pLLThreshold, "P2P_LL_THRESHOLD", 16384);
 // ensure *nWorkBudget >= 1 upon entry.
 static ncclResult_t addP2pToPlan(
     struct ncclComm* comm, struct ncclKernelPlan* plan, int* nWorkBudget,
-    bool isSendNotRecv, int peer, int chunk, void *addr, size_t bytes, bool fuseOk
+    bool isSendNotRecv, int peer, int chunk, void *addr, size_t bytes, bool fuseOk,
+    unsigned long long ncclFuncTimes, uint64_t groupHash
   ) {
   struct ncclInfo info = {
     isSendNotRecv ? ncclFuncSend : ncclFuncRecv,
@@ -558,6 +568,11 @@ static ncclResult_t addP2pToPlan(
   // Calculate the opCount after appendWorkElemP2p since it will always return
   // with channel->nWork equal to one plus the work index this p2p settled in.
   proxyOp.opCount = uint64_t(plan->channels[channelId].nWork)<<1 | 1;
+  
+  proxyOp.ncclFuncTimes = ncclFuncTimes;
+  proxyOp.groupHash = groupHash;
+  proxyOp.coll = info.coll;
+  
   NCCLCHECK(addProxyOpIfNeeded(comm, plan, &proxyOp));
   return ncclSuccess;
 }
@@ -950,7 +965,7 @@ static ncclResult_t scheduleP2pTasksToPlan(
           if (recvChunkBytes != 0) {
             if (recvChunkBytes == -1) recvChunkBytes = 0;
             if (*nWorkBudget < 1) return ncclSuccess; // ensure room in budget
-            NCCLCHECK(addP2pToPlan(comm, plan, nWorkBudget, /*isSendNotRecv=*/false, recvPeer, recv->chunk, recvPtr, recvChunkBytes, fuseOk));
+            NCCLCHECK(addP2pToPlan(comm, plan, nWorkBudget, /*isSendNotRecv=*/false, recvPeer, recv->chunk, recvPtr, recvChunkBytes, fuseOk, recv->ncclFuncTimes, recv->groupHash));
             fuseOk = true;
             recvPtr += recvChunkBytes;
             recvBytes -= recvChunkBytes;
@@ -964,7 +979,7 @@ static ncclResult_t scheduleP2pTasksToPlan(
           if (sendChunkBytes != 0) {
             if (sendChunkBytes == -1) sendChunkBytes = 0;
             if (*nWorkBudget < 1) return ncclSuccess; // ensure room in budget
-            NCCLCHECK(addP2pToPlan(comm, plan, nWorkBudget, /*isSendNotRecv=*/true, sendPeer, send->chunk, sendPtr, sendChunkBytes, fuseOk));
+            NCCLCHECK(addP2pToPlan(comm, plan, nWorkBudget, /*isSendNotRecv=*/true, sendPeer, send->chunk, sendPtr, sendChunkBytes, fuseOk, send->ncclFuncTimes, send->groupHash));
             fuseOk = true;
             sendPtr += sendChunkBytes;
             sendBytes -= sendChunkBytes;
@@ -1776,6 +1791,8 @@ static ncclResult_t computeCollChunkInfo(struct ncclInfo* collInfo, size_t nByte
 }
 
 static ncclResult_t initCollProxyOp(struct ncclInfo* collInfo, int channelId, uint64_t opCount, uint32_t nsteps, struct ncclProxyOp* proxyOp) {
+  proxyOp->groupHash = collInfo->comm->groupHash;
+  proxyOp->ncclFuncTimes = collInfo->ncclFuncTimes;
   proxyOp->nsteps = nsteps;
   proxyOp->sliceSteps = collInfo->sliceSteps;
   proxyOp->chunkSteps = collInfo->chunkSteps;
@@ -1925,6 +1942,9 @@ static ncclResult_t taskAppend(struct ncclComm* comm, struct ncclInfo* info) {
     p2p->buff = (void*)info->recvbuff;
     p2p->bytes = nBytes;
     p2p->chunk = 0;
+    p2p->ncclFuncTimes = comm->ncclFuncTimes;
+    p2p->groupHash = comm->groupHash;
+
     ncclIntruQueueEnqueue(
       isSendNotRecv ? &tasks->peers[peer].sendQueue : &tasks->peers[peer].recvQueue,
       p2p);
@@ -2022,6 +2042,13 @@ ncclResult_t ncclEnqueueCheck(struct ncclInfo* info) {
   INFO(NCCL_COLL,"%s: opCount %lx sendbuff %p recvbuff %p count %zi datatype %d op %d root %d comm %p [nranks=%d] stream %p",
         info->opName, info->comm->opCount, info->sendbuff, info->recvbuff, info->count,
         info->datatype, info->op, info->root, info->comm, info->comm->nRanks, info->stream);
+  
+   //jfz
+  struct timespec time_api;
+  clock_gettime(CLOCK_REALTIME, &time_api);
+  if(nccl_megatrace_enable){
+    log_event(time_api, info->count, info->opName, info->stream, info->comm->opCount, info->comm->groupHash);
+  }
   TRACE_CALL("nccl%s(%" PRIx64 ",%" PRIx64 ",%zi,%d,%d,%d,%p,%p)", info->opName, reinterpret_cast<int64_t>(info->sendbuff), reinterpret_cast<int64_t>(info->recvbuff), info->count, info->datatype, info->op, info->root, info->comm, info->stream);
 
   NCCLCHECKGOTO(taskAppend(info->comm, info), ret, fail);
diff --git a/src/graph/search.cc b/src/graph/search.cc
index c7b4d96..d206730 100644
--- a/src/graph/search.cc
+++ b/src/graph/search.cc
@@ -1114,6 +1114,7 @@ NCCL_PARAM(P2pPxnLevel, "P2P_PXN_LEVEL", 2);
 ncclResult_t ncclTopoGetNetDev(struct ncclComm* comm, int rank, struct ncclTopoGraph* graph, int channelId, int peerRank, int64_t* id, int* dev, int* proxyRank) {
   int64_t netId = -1;
   int netDev = -1;
+
   if (graph) {
     // Honor the net device in the graph
     int channel = channelId%graph->nChannels;
@@ -1124,6 +1125,7 @@ ncclResult_t ncclTopoGetNetDev(struct ncclComm* comm, int rank, struct ncclTopoG
     } else {
       NCCLCHECK(getNvlsNetDev(comm, graph, channelId, &netId));
     }
+
     NCCLCHECK(ncclTopoIdToNetDev(comm->topo, netId, &netDev));
     if (dev) *dev = netDev;
     if (id) *id = netId;
diff --git a/src/include/comm.h b/src/include/comm.h
index 0ba913a..dc01f88 100644
--- a/src/include/comm.h
+++ b/src/include/comm.h
@@ -393,6 +393,8 @@ struct ncclComm {
   void *tunerContext;
   // buffer registration cache
   struct ncclRegCache regCache;
+  uint64_t groupHash;
+  unsigned long long ncclFuncTimes = 0;
   uint64_t endMagic;
 };
 
diff --git a/src/include/info.h b/src/include/info.h
index 0d53b9a..1dd1447 100644
--- a/src/include/info.h
+++ b/src/include/info.h
@@ -73,6 +73,8 @@ struct ncclInfo {
   int protocol;
   bool userTuned;
   struct ncclInfo *next;
+  unsigned long long ncclFuncTimes;
+  uint64_t groupHash;
 };
 
 inline ncclResult_t ncclInfoSetDerived(struct ncclInfo* info, int nRanks) {
@@ -115,6 +117,8 @@ struct ncclTaskP2p {
   // Stateful chunk index. If a p2p gets "cut" over two plans this keeps track
   // of where it left off.
   int chunk;
+  unsigned long long ncclFuncTimes;
+  uint64_t groupHash;
 };
 
 struct ncclCudaStreamList {
diff --git a/src/include/proxy.h b/src/include/proxy.h
index cb1c3b2..f12270c 100644
--- a/src/include/proxy.h
+++ b/src/include/proxy.h
@@ -57,6 +57,10 @@ struct ncclProxyOp {
   union ncclProxyOpSpecifics specifics;
 
   struct ncclProxyOp *enqNext;
+  unsigned long long ncclFuncTimes;
+  int peerRank;
+  int rank;
+  uint64_t groupHash;
 };
 
 struct ncclProxySubArgs {
@@ -119,6 +123,10 @@ struct ncclProxyArgs {
   struct ncclProxyArgs** proxyAppendPtr;
 
   union ncclProxyOpSpecifics specifics;
+  unsigned long long ncclFuncTimes;
+  int peerRank;
+  int rank;
+  uint64_t groupHash;
 };
 #define NCCL_MAX_NETDEVS 128
 
diff --git a/src/include/ring_log.h b/src/include/ring_log.h
new file mode 100644
index 0000000..734cd45
--- /dev/null
+++ b/src/include/ring_log.h
@@ -0,0 +1,69 @@
+#ifndef RING_LOG_H
+#define RING_LOG_H
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <timer.h>
+#include <time.h>
+#include <sys/types.h>
+#include <string.h>
+#include <pthread.h>
+#include <signal.h>
+#include "socket.h"
+#include "nccl.h"
+#include "core.h"
+#include <atomic>   
+#include <cstring>
+#include <unistd.h>
+#include <cuda_runtime.h>
+#include <atomic>
+
+
+#define RING_BUFFER_SIZE 10000  //  
+#define LOG_MAX_LEN 128       //  
+#define BATCH_SIZE        10240      //  
+#define FLUSH_INTERVAL_MS 4000 //  
+#define MEGATRACE_LOG_ENABLE           1
+//#define NCCL_COLL_LOG 0
+//#define NCCL_TELEMERTRY_LOG 1
+extern const int nccl_megatrace_enable;
+extern const char* nccl_megatrace_log_path;
+
+
+
+//  
+typedef struct {
+    char msg[LOG_MAX_LEN];
+    char type;
+} log_entry_t;
+
+
+//  
+typedef struct {
+    log_entry_t buffer[RING_BUFFER_SIZE];
+    pthread_t thread;
+    volatile int live = -1;
+    std::atomic<int64_t> last_write_ts;
+    std::atomic<int> head;  // 
+    std::atomic<int> tail;  //  
+} ring_buffer_t;
+
+
+
+void ring_buffer_init(ring_buffer_t *rb) ;
+int ring_buffer_count(ring_buffer_t *rb) ;
+int ring_buffer_push(ring_buffer_t *rb, const char *msg);
+int ring_buffer_pop_batch(ring_buffer_t *rb, log_entry_t *out_entries, int max_entries) ;
+void *log_writer_thread(void *arg) ;
+void log_event(struct timespec time_api, size_t count, const char* opName, cudaStream_t stream,int64_t opCount,int64_t groupHash);
+
+
+
+#ifdef MEGA_CC
+ring_buffer_t ring_nccl_log;
+#else
+extern ring_buffer_t ring_nccl_log;
+#endif
+
+
+#endif
diff --git a/src/include/timer_log.h b/src/include/timer_log.h
new file mode 100644
index 0000000..3f03833
--- /dev/null
+++ b/src/include/timer_log.h
@@ -0,0 +1,266 @@
+#ifndef TIMER_LOG_H
+#define TIMER_LOG_H
+
+#include <mutex>
+#include <stdlib.h>
+#include <stdio.h>
+#include <timer.h>
+#include <sys/types.h>
+#include <string.h>
+// #include <cstdint>
+#include <pthread.h>
+#include <signal.h>
+#include "socket.h"
+#include "nccl.h"
+#include "core.h"
+#include <deque>
+#include <queue>
+#include <stack>
+
+enum timer_log_type{
+  NCCL_LOG_NOT_USE = 0,
+  NCCL_LOG_TELEMETRY = 1,
+  NCCL_LOG_HANG = 2
+};
+
+struct timer_log{
+  int rank;
+  int channel_id;
+  uint8_t func;
+  unsigned long long ncclFuncTimes;
+  uint8_t srcIp[4];
+  uint8_t dscIp[4];
+  struct timespec send_start;
+  struct timespec send_end;  
+  int loged_start;
+  int loged_end;
+  unsigned long long diff;
+  int size = 0;
+  double rate;
+  std::string NetworkCardName;
+  int peerRank;
+  uint64_t groupHash;
+  int sendWrCounter;
+  int devIndex;
+  int remainWrDataSize;
+};
+
+// define the size of windowsSize
+const int maxWindowSize = ncclGetEnv("TELEMETRY_WINDOWSIZE") ? 
+                          atoi(ncclGetEnv("TELEMETRY_WINDOWSIZE")) : 
+                          50;
+
+enum linkStatus{
+  LINK_STATUS_UNUSED,
+  LINK_STATUS_USED,
+  LINK_STATUS_WAIT,
+  LINK_STATUS_SUCCESS,
+  LINK_STATUS_WRONG,
+  LINK_STATUS_WRONG_WAIT
+};
+
+struct linkStatusTest{
+  int status;
+  struct ibv_qp *linkPingQp;
+  struct timespec send_start;
+  struct timespec send_end;
+  int events;
+};
+
+extern const int nccl_telemetry_enable;
+extern const char* nccl_telemetry_log_path;
+
+//INFO(NCCL_ENV, "NCCL_TELEMETRY_ENABLE is set to %d", nccl_telemetry_enable);
+//INFO(NCCL_ENV, "NCCL_TELEMETRY_LOG_PATH is set to %s", nccl_telemetry_log_path);
+
+
+
+#define TIMER_LOG_ENTRY           nccl_telemetry_enable
+#define TIMER_LOG_NCCL_HANG       nccl_telemetry_enable
+#define TIMER_LOG_NCCL_TELEMETRY  nccl_telemetry_enable
+
+
+#define TIMER_LOG_QUEUE_READ -1
+#define TIMER_LOG_QUEUE_WRITE 1
+
+#define SOCK_PATH "/tmp/unix_sock"
+void* timerLogService(void *args);
+void printLogInfo(struct timer_log log);
+
+
+#define TIMER_LOG_MAX_LEN 50010
+struct timer_log_queue{
+  pthread_t thread;
+  pthread_mutex_t lock;
+  std::mutex telemetryStateLock;
+  volatile int state;
+  volatile int stop;
+  std::deque<timer_log> log;
+  std::queue<timer_log> slideWindow[2];     // different port
+  volatile unsigned long long windowDataSizes[2];
+  volatile unsigned long long sendEndTime[2];  // count the timestamp of the last log in slideWindow
+  volatile timer_log* lastLog[2];             // the last log of different devIndex in Log, for push operation when log is full
+  volatile bool collect;
+  volatile int live = -1;
+
+  void push(struct timer_log& _log){
+    if (log.size() >= TIMER_LOG_MAX_LEN) {
+      if (lastLog[_log.devIndex]!= NULL && lastLog[_log.devIndex]->ncclFuncTimes == _log.ncclFuncTimes) {
+        // merge the new log into before one
+        lastLog[_log.devIndex]->size += _log.size;
+        lastLog[_log.devIndex]->diff = _log.diff;
+        lastLog[_log.devIndex]->func = _log.func;
+      }
+      else {
+        // merge the first two log that have same ncclFuncTimes
+        std::stack<timer_log> stk;
+        while(!log.empty()){
+          timer_log frontLog = log.front();
+          log.pop_front();
+          if (!stk.empty() && stk.top().ncclFuncTimes == frontLog.ncclFuncTimes && stk.top().devIndex == frontLog.devIndex) {
+            stk.top().size += frontLog.size;
+            stk.top().diff = frontLog.diff;
+            break;
+          }
+          stk.push(frontLog);
+        }
+        while(!stk.empty()) {
+          timer_log topLog = stk.top();
+          log.push_front(topLog);
+          stk.pop();
+        }
+        log.push_back(_log);
+        lastLog[_log.devIndex] = &log.back();
+      }
+    }
+    else {
+      log.push_back(_log);
+      lastLog[_log.devIndex] = &log.back();
+    }
+    return;
+  }
+  struct timer_log pop(){
+    if (log.empty()) {
+      struct timer_log res;
+      memset((void *)&res, 0, sizeof(res));
+      return res;
+    }
+    timer_log popLog = log.front();
+    // judge if the pop one is the last log of its devIndesx
+    if (lastLog[popLog.devIndex] == &log.front())
+    {
+      lastLog[popLog.devIndex] = NULL;
+    }
+
+    log.pop_front(); 
+    return popLog;
+  }
+  bool empty() {
+    while (!log.empty()) {
+      log.pop_back();
+    }
+    return true;
+  }
+
+  void pushSlideWindow(struct timer_log& _log, int devIndex) {
+    if (!slideWindow[devIndex].empty() && 
+        (slideWindow[devIndex].back().ncclFuncTimes != _log.ncclFuncTimes)) {
+      emptySlideWindow(devIndex);
+      lastLog[0] = NULL;
+      lastLog[1] = NULL;
+      windowDataSizes[devIndex] = 0;
+    }
+    if (slideWindow[devIndex].size() >= maxWindowSize) {
+      timer_log frontLog = slideWindow[devIndex].front();
+      slideWindow[devIndex].pop();
+      windowDataSizes[devIndex] -= frontLog.size;
+    }
+    slideWindow[devIndex].push(_log);
+    sendEndTime[devIndex] = _log.diff;
+    windowDataSizes[devIndex] += _log.size;
+    return;
+  }
+
+  void popSlideWindow(int devIndex) {
+    if (!slideWindow[devIndex].empty()) {
+      slideWindow[devIndex].pop();
+    }
+    return;
+  }
+
+  void emptySlideWindow(int devIndex) {
+    while (!slideWindow[devIndex].empty()) {
+      slideWindow[devIndex].pop();
+    }
+    return;
+  }
+
+  int getBandWidths(int devIndex) {
+    if (slideWindow[devIndex].size() <= 1) {
+      return 0;
+    }
+
+    // Gbps
+    unsigned long long sendTime = sendEndTime[devIndex] - slideWindow[devIndex].front().diff;
+    unsigned long long sendDataSizes = windowDataSizes[devIndex] - slideWindow[devIndex].front().size;
+    // 0.93 = 1e9 / 1024 * 1024 * 1024
+    return sendDataSizes * 0.93 * 8 / sendTime;
+  }
+
+  void init(){
+    std::lock_guard<std::mutex> stateLock(telemetryStateLock);
+    if(live == -1){
+      state = 0;
+      stop = 0;
+      windowDataSizes[0] = 0;
+      windowDataSizes[1] = 0;
+      lastLog[0] = NULL;
+      lastLog[1] = NULL;
+      collect = 0;
+      live = 1;
+      pthread_mutex_init(&lock, NULL);
+      pthread_create(&thread, NULL, timerLogService, NULL);
+    }
+  }
+  bool setState(int to){
+    // return 1;
+
+    if(state != 0) return 0;
+    if(pthread_mutex_trylock(&lock) == 0){
+      if(state == 0) state = to;
+      pthread_mutex_unlock(&lock);
+      return state == to;
+    }
+    return 0;
+  } 
+  void freeState(){
+    // pthread_mutex_lock(&lock);
+    state = 0;
+    // pthread_mutex_unlock(&lock);
+  }
+  void destroy(){
+    std::lock_guard<std::mutex> stateLock(telemetryStateLock);
+    if(live == 1){
+      stop = 1;
+      pthread_join(thread, nullptr);
+      live = 0;
+    }
+  }
+};
+
+#ifdef NET_IB_CC
+struct timer_log_queue global_timer_log;
+#else
+extern struct timer_log_queue global_timer_log;
+#endif
+
+
+
+/*diff net_ib.cc:
+ *#define NET_IB_CC
+ *#include "timer_log.h"
+ *proxy.cc:
+ *pthread_create(&global_timer_log.thread, NULL, timerLogService, NULL);
+ */
+
+#endif
diff --git a/src/init.cc b/src/init.cc
index cecb9bc..206360f 100644
--- a/src/init.cc
+++ b/src/init.cc
@@ -26,6 +26,7 @@
 #include <sys/stat.h>
 #include <unistd.h>
 #include "param.h"
+#include "timer_log.h"
 
 #define STR2(v) #v
 #define STR(v) STR2(v)
@@ -469,7 +470,7 @@ fail:
 }
 
 // Pre-process the string so that running "strings" on the lib can quickly reveal the version.
-#define VERSION_STRING "NCCL version " STR(NCCL_MAJOR) "." STR(NCCL_MINOR) "." STR(NCCL_PATCH) NCCL_SUFFIX "+cuda" STR(CUDA_MAJOR) "." STR(CUDA_MINOR)
+#define VERSION_STRING "VCCL version " STR(NCCL_MAJOR) "." STR(NCCL_MINOR) "." STR(NCCL_PATCH) NCCL_SUFFIX "+cuda" STR(CUDA_MAJOR) "." STR(CUDA_MINOR)
 static void showVersion() {
   static int shown = 0;
   if (shown == 0 && ncclDebugLevel >= NCCL_LOG_VERSION) {
@@ -1790,6 +1791,7 @@ static ncclResult_t ncclCommInitRankDev(ncclComm_t* newcomm, int nranks, ncclUni
   comm->initState = ncclInternalError;
   *newcomm = comm;
 
+  comm->groupHash = hashUniqueId(commId);
   NCCLCHECKGOTO(ncclCalloc(&job, 1), res, fail);
   job->comm = comm;
   job->nranks = nranks;
diff --git a/src/net.cc b/src/net.cc
index e978a18..380a92d 100644
--- a/src/net.cc
+++ b/src/net.cc
@@ -417,11 +417,7 @@ static void* openNetPluginLib(void) {
 }
 
 ncclResult_t ncclNetPluginInit() {
-  void* netPluginLib = openNetPluginLib();
-  if (netPluginLib == nullptr) {
-    INFO(NCCL_INIT|NCCL_NET, "NET/Plugin: Using internal network plugin.");
-    return ncclSuccess;
-  }
+  void* netPluginLib = NULL;
 
   ncclNets[0] = (ncclNet_v8_t*)dlsym(netPluginLib, "ncclNetPlugin_v8");
   if (ncclNets[0] == nullptr) {
diff --git a/src/proxy.cc b/src/proxy.cc
index 955c415..88651d0 100644
--- a/src/proxy.cc
+++ b/src/proxy.cc
@@ -12,12 +12,15 @@
 #include "profiler.h"
 #define ENABLE_TIMER 0
 #include "timer.h"
+#include "ring_log.h" 
 
 #include <sys/syscall.h>
 #include <assert.h>
 #include <unistd.h>
 #include <sys/time.h>
-
+#include "ring_log.h"
+#include "timer_log.h"
+extern const int nccl_megatrace_enable;
 enum { proxyRecv=0, proxySend=1 };
 
 static bool NeedProxy(int type, int pattern, int root, struct ncclRing* ring, int nranks) {
@@ -397,6 +400,10 @@ static ncclResult_t ncclProxyOpToArgs(struct ncclProxyOp* op, struct ncclProxyAr
   args->state = ncclProxyOpReady;
   args->progress = op->connection->tcomm->proxyProgress;
   args->proxyAppendPtr = op->connection->proxyAppendPtr;
+  args->ncclFuncTimes = op->ncclFuncTimes;
+  args->peerRank = op->peerRank;
+  args->groupHash = op->groupHash;
+  args->rank = op->rank;
   return ncclSuccess;
 }
 
@@ -514,7 +521,8 @@ static ncclResult_t ncclLocalOpAppend(struct ncclComm* comm, struct ncclProxyCon
 
 static ncclResult_t SaveProxy(struct ncclComm* comm, struct ncclChannel* channel, int type, int peer, struct ncclProxyOp* op, int connIndex, bool* justInquire) {
   if (peer < 0) return ncclSuccess;
-
+  op->peerRank = peer;
+  op->rank = comm->rank;
   struct ncclChannelPeer* peerComm = channel->peers[peer];
   struct ncclConnector* connector = type == proxyRecv ? peerComm->recv+connIndex : peerComm->send+connIndex;
   if (connector->transportComm == NULL) {
@@ -1699,6 +1707,16 @@ ncclResult_t ncclProxyCreate(struct ncclComm* comm) {
     proxyState->ncclCollNet = comm->ncclCollNet;
     memcpy(proxyState->buffSizes, comm->buffSizes, sizeof(comm->buffSizes));
 
+    if (TIMER_LOG_ENTRY) {
+      global_timer_log.init();
+    }
+
+    if(ring_nccl_log.live == -1){
+      ring_buffer_init(&ring_nccl_log);
+      if(nccl_megatrace_enable){
+          pthread_create(&ring_nccl_log.thread, NULL, log_writer_thread, NULL);
+      }
+    }
     pthread_create(&comm->proxyState->thread, NULL, ncclProxyService, comm->proxyState);
     ncclSetThreadName(comm->proxyState->thread, "NCCL Service %2d", comm->cudaDev);
 
@@ -1758,6 +1776,10 @@ ncclResult_t ncclProxyStop(struct ncclComm* comm) {
 }
 
 ncclResult_t ncclProxyDestroy(struct ncclComm* comm) {
+
+  if(TIMER_LOG_ENTRY){
+    global_timer_log.destroy();
+  }
   struct ncclProxyState* sharedProxyState = comm->sharedRes->proxyState;
 
   assert(sharedProxyState->refCount == 0);
diff --git a/src/tools/rate_from_log.py b/src/tools/rate_from_log.py
new file mode 100644
index 0000000..212fd50
--- /dev/null
+++ b/src/tools/rate_from_log.py
@@ -0,0 +1,277 @@
+import argparse
+import os
+import re
+import sys
+from collections import defaultdict
+import logging
+import copy
+
+# Define enumeration mappings for func values
+FUNC_ENUM = {
+    0: "ncclFuncBroadcast",
+    1: "ncclFuncReduce",
+    2: "ncclFuncAllGather",
+    3: "ncclFuncReduceScatter",
+    4: "ncclFuncAllReduce",
+    5: "ncclFuncSendRecv",
+    6: "ncclFuncSend",
+    7: "ncclFuncRecv",
+    8: "ncclNumFuncs"
+}
+logging.basicConfig(filename='debug.log', level=logging.DEBUG, 
+                     format='%(asctime)s - %(levelname)s - %(message)s')
+
+
+def detect_cycles(data, output_file_path):
+    """
+    Detects loops in the direction of the rank flow and writes the results to an output file.
+    """
+    
+    def find_cycles(graph):
+        index = 0
+        stack = []
+        indices = {}
+        lowlink = {}
+        on_stack = set()
+        cycles = []
+
+        def strongconnect(v):
+            nonlocal index
+            indices[v] = index
+            lowlink[v] = index
+            index += 1
+            stack.append(v)
+            on_stack.add(v)
+
+            for w in graph[v]:
+                if w not in indices:
+                    strongconnect(w)
+                    lowlink[v] = min(lowlink[v], lowlink[w])
+                elif w in on_stack:
+                    lowlink[v] = min(lowlink[v], indices[w])
+
+            if lowlink[v] == indices[v]:
+                cycle = []
+                while True:
+                    w = stack.pop()
+                    on_stack.remove(w)
+                    cycle.append(w)
+                    if w == v:
+                        break
+                cycles.append(cycle)
+
+        graph_copy = copy.deepcopy(graph)
+        for v in graph_copy:
+            if v not in indices:
+                strongconnect(v)
+
+
+        return cycles
+
+    output_dir = os.path.dirname(output_file_path)
+    if output_dir and not os.path.exists(output_dir):
+        os.makedirs(output_dir)
+
+    try:
+        with open(output_file_path, 'w') as output_file:
+            for group, funcs in data.items():
+                for func_description, func_timess in funcs.items():
+                    for func_times, channels in func_timess.items():
+                        for channel, flows in channels.items():
+                            graph = defaultdict(list)
+                            flow_keys = list(flows.keys()) 
+                            for flow in flow_keys:
+                                from_rank, to_rank = map(int, flow.split('->'))
+                                graph[from_rank].append(to_rank)
+                                
+                            cycles = find_cycles(graph)
+                            for cycle in cycles:
+                                output_file.write(f"Detected cycle in group {group}, func {func_description}, func_time {func_times}, channel {channel}: {' -> '.join(map(str, cycle))}\n")
+
+                                
+        logging.info(f"Cycle detection results have been written to {output_file_path}")
+        print(f"Cycle detection results have been written to {output_file_path}")
+    except Exception as e:
+        logging.error(f"Error writing to output file {output_file_path}: {e}")
+        print(f"Error writing to output file {output_file_path}: {e}")
+
+
+def process_logs(log_folder_path, output_file_path, cycle_output_file_path):
+    """
+    Processes the log file to calculate the transfer rate and writes the result to the output file.
+    """
+    log_pattern = re.compile(
+        r'(\S+):(\S+):(\d+): Group:(\d+), from rank (\d+) to rank (\d+), channel_id:(\d+), func:(\d+),FuncTimes:(\d+), (\d+\.\d+\.\d+\.\d+)->(\d+\.\d+\.\d+\.\d+) send (\d+) Bytes used (\d+) nsec'
+    )
+
+    data = defaultdict(lambda: defaultdict(lambda: defaultdict(lambda: defaultdict(lambda: defaultdict(lambda: defaultdict(lambda: {
+        "bytes_sent": [],
+        "time_used": [],
+        "node": [],
+        "cards": [],
+        "timestamp": [],
+        "src_ip": [],
+        "dst_ip": [],
+    }))))))
+
+    for root, _, files in os.walk(log_folder_path):
+        for log_file in files:
+            if log_file.endswith('.log'):  # .log only
+                log_file_path = os.path.join(root, log_file)
+                if os.path.isfile(log_file_path):
+                    try:
+                        with open(log_file_path, 'r') as file:
+                            for line in file:
+                                match = log_pattern.match(line.strip())
+                                if match:
+                                    groups = match.groups()
+                                    if len(groups) != 13:
+                                        logging.error(f"Unexpected number of groups: {len(groups)}")
+                                        return  
+                                    node, cards, timestamp, group, from_rank, to_rank, channel, func, func_times, src_ip, dst_ip, bytes_sent, time_used = groups
+                                    bytes_sent = int(bytes_sent)
+                                    time_used = int(time_used)
+                                    func_description = FUNC_ENUM.get(int(func), "Unknown")
+                                    flow = f"{from_rank}->{to_rank}"
+                                    ip_flow = f"{src_ip}->{dst_ip}"
+                                    data[group][func_description][func_times][channel][flow][ip_flow]["bytes_sent"].append(bytes_sent)
+                                    data[group][func_description][func_times][channel][flow][ip_flow]["time_used"].append(time_used)
+                                    data[group][func_description][func_times][channel][flow][ip_flow]["node"].append(node)
+                                    data[group][func_description][func_times][channel][flow][ip_flow]["cards"].append(cards)
+                                    data[group][func_description][func_times][channel][flow][ip_flow]["timestamp"].append(timestamp)
+                                    #data[group][func_description][flow][ip_flow]["channel"].append(channel)
+                                    data[group][func_description][func_times][channel][flow][ip_flow]["src_ip"].append(src_ip)
+                                    data[group][func_description][func_times][channel][flow][ip_flow]["dst_ip"].append(dst_ip)
+                                    #data[group][func_description][func_times][channel][flow][ip_flow]["func_times"].append(func_times)
+                                    if group not in data :
+                                        logging.error(f"Missing keys: [group] in data structure for group {group}, func {func_description}, func_times {func_times}, channel {channel}, flow {flow}, ip_flow {ip_flow}")
+                                        continue
+                                    if func_description not in data[group]:
+                                        logging.error(f"Missing keys: [func_description] in data structure for group {group}, func {func_description}, func_times {func_times}, channel {channel}, flow {flow}, ip_flow {ip_flow}")
+                                        continue
+                                    if func_times not in data[group][func_description]:
+                                        logging.error(f"Missing keys: [func_times] in data structure for group {group}, func {func_description}, func_times {func_times}, channel {channel}, flow {flow}, ip_flow {ip_flow}")
+                                        continue
+                                    if  channel not in data[group][func_description][func_times]:
+                                        logging.error(f"Missing keys: [channel] in data structure for group {group}, func {func_description}, func_times {func_times}, channel {channel}, flow {flow}, ip_flow {ip_flow}")
+                                        continue
+                                    if  ip_flow not in data[group][func_description][func_times][channel][flow] :
+                                        logging.error(f"Missing keys: [ip_flow] in data structure for group {group}, func {func_description}, func_times {func_times}, channel {channel}, flow {flow}, ip_flow {ip_flow}")
+                                        continue
+                                else:
+                                    logging.warning(f"Skipping line: {line.strip()}")
+                    except PermissionError:
+                        logging.error(f"PermissionError: Cannot read file {log_file_path}")
+                    except Exception as e:
+                        logging.error(f"Error processing file {log_file_path}: {e}")
+
+    detect_cycles(data, cycle_output_file_path)
+    
+    file_results = defaultdict(lambda:defaultdict(lambda: defaultdict(lambda: defaultdict(lambda: defaultdict(lambda: defaultdict(list))))))
+
+    for group, funcs in data.items():
+        for func_description, func_timess in funcs.items():
+            for func_times, channels in func_timess.items():
+                for channel, flows in channels.items():
+                    for flow, ip_flows in flows.items():
+                        for ip_flow, metrics in ip_flows.items():
+                            total_bytes = sum(metrics["bytes_sent"])
+                            total_time = sum(metrics["time_used"])
+                            if total_time > 0:
+                                transmission_rate_gbps = (total_bytes * 8) / total_time
+                            else:
+                                transmission_rate_gbps = 0
+                            file_results[group][func_description][func_times][channel][flow][ip_flow].append(transmission_rate_gbps)
+
+    group_rates = defaultdict(list)
+    lowest_rate_info = {"group": None, "func": None, "func_times": None, "channel": None, "flow": None, "ip_flow": None, "rate": float('inf')}
+    for group, funcs in file_results.items():
+        for func_description, func_timess in funcs.items():
+            for func_times, channels in func_timess.items():
+                for channel, flows in channels.items():
+                    for flow, ip_flows in flows.items():
+                        for ip_flow, rates in ip_flows.items():
+                            if rates:
+                                average_rate = sum(rates) / len(rates)
+                                group_rates[group].append((group, func_description, func_times, channel, flow, ip_flow, average_rate))
+                                if min(rates) < lowest_rate_info["rate"]:
+                                    lowest_rate_info = {
+                                        "group": group,
+                                        "func": func_description,
+                                        "func_times": func_times,
+                                        "channel": channel,
+                                        "flow": flow,
+                                        "ip_flow": ip_flow,
+                                        "rate": min(rates)
+                                    }
+    total_rates = [rate for group_rates in file_results.values() for funcs in group_rates.values() for func_timess in funcs.values() 
+                    for channels in func_timess.values() for flows in channels.values() for ip_flows in flows.values() for rate in ip_flows]
+    average_transmission_rate_gbps = sum(total_rates) / len(total_rates) if total_rates else 0
+
+    output_dir = os.path.dirname(output_file_path)
+    if output_dir and not os.path.exists(output_dir):
+        os.makedirs(output_dir)
+    
+    try:
+        with open(output_file_path, 'w') as output_file:
+            for group, items in group_rates.items():
+                average_rate = sum(item[6] for item in items) / len(items) if items else 0
+                lowest_rate_info_group = min(items, key=lambda x: x[6]) if items else None
+                output_file.write(f"Group: {group}\n")
+                output_file.write(f"  Average Transmission Rate:\n")
+                output_file.write(f"    Average Rate: {average_rate:.9f} Gb/s\n")
+                if lowest_rate_info_group:
+                    output_file.write(f"  Lowest Transmission Rate:\n")
+                    output_file.write(
+                        f"    Func: {lowest_rate_info_group[1]}, Func_times: {lowest_rate_info_group[2]}, Channel: {lowest_rate_info_group[3]}, Flow: {lowest_rate_info_group[4]}, IP Flow: {lowest_rate_info_group[5]}, Transmission Rate: {lowest_rate_info_group[6]:.9f} Gb/s\n")
+                else:
+                    output_file.write(f"  Lowest Transmission Rate: Not available\n")
+                output_file.write("\n")
+
+            output_file.write(
+                f"Average Transmission Rate across the Network: {average_transmission_rate_gbps:.9f} Gb/s\n")
+            output_file.write(f"Overall Lowest Transmission Rate across the Network:\n")
+            output_file.write(
+                f"  Group: {lowest_rate_info['group']}, Func: {lowest_rate_info['func']}, Func_times: {lowest_rate_info['func_times']}, Channel: {lowest_rate_info['channel']}, Flow: {lowest_rate_info['flow']}, IP Flow: {lowest_rate_info['ip_flow']}, Transmission Rate: {lowest_rate_info['rate']:.9f} Gb/s\n")
+
+            output_file.write("\nDetailed Data Structure:\n")
+            for group, funcs in data.items():
+                output_file.write(f"Group: {group}\n")
+                for func_description, func_timess in funcs.items():
+                    for func_times, channels in func_timess.items():
+                        for channel, flows in channels.items():
+                            for flow, ip_flows in flows.items():
+                                for ip_flow, metrics in ip_flows.items():
+                                    avg_bytes = sum(metrics["bytes_sent"]) / len(metrics["bytes_sent"]) if metrics[
+                                        "bytes_sent"] else 0
+                                    avg_time = sum(metrics["time_used"]) / len(metrics["time_used"]) if metrics["time_used"] else 0
+                                    avg_rate = (avg_bytes * 8) / avg_time if avg_time > 0 else 0
+                                    output_file.write(f"    Func: {func_description}, Func_times: {func_times}, Channel: {channel}, Flow: {flow}, IP Flow: {ip_flow}\n")
+                                    output_file.write(f"      Average Bytes Sent: {avg_bytes}\n")
+                                    output_file.write(f"      Average Time Used: {avg_time}\n")
+                                    output_file.write(f"      Average Transmission Rate: {avg_rate:.9f} Gb/s\n")
+
+        print(f"Transmission rates by group have been calculated and written to {output_file_path}")
+        print(f"Average transmission rate across the network: {average_transmission_rate_gbps:.9f} Gb/s")
+        print(f"Overall lowest transmission rate across the network: {lowest_rate_info['rate']:.9f} Gb/s")
+    except Exception as e:
+        print(f"Error writing to output file {output_file_path}: {e}")
+        logging.error(f"Error writing to output file {output_file_path}: {e}")
+    
+if __name__ == "__main__":
+    parser = argparse.ArgumentParser(description="Process log files to calculate transmission rates.")
+    parser.add_argument("log_folder_path", type=str, help="The path to the log folder.")
+    parser.add_argument("output_file_path", type=str, help="The path to the output file.")
+    parser.add_argument("cycle_output_file_path", type=str, help="The path to the output file for cycle detection results.")
+    
+    args = parser.parse_args()
+
+    if not os.path.isdir(args.log_folder_path):
+        logging.error(f"Error: {args.log_folder_path} is not a valid directory.")
+        sys.exit(1)
+
+    if os.path.exists(args.output_file_path) and not os.access(args.output_file_path, os.W_OK):
+        logging.error(f"Error: No write permission for {args.output_file_path}.")
+        sys.exit(1)
+        
+    process_logs(args.log_folder_path, args.output_file_path, args.cycle_output_file_path)
diff --git a/src/transport/net.cc b/src/transport/net.cc
index cc38821..0e896a7 100644
--- a/src/transport/net.cc
+++ b/src/transport/net.cc
@@ -165,6 +165,14 @@ struct setupReq {
   int connIndex;
 };
 
+extern ncclResult_t saveChannelToQp(void* netSendComm, int channel_id);
+extern ncclResult_t setCommunicationAlgorithm(void *netSendComm, uint8_t func);
+extern ncclResult_t setNcclFuncTimes(void *netSendComm, unsigned long long ncclFuncTimes);
+extern ncclResult_t setNcclPeerRank(void *netSendComm, int rank);
+extern ncclResult_t setNcclGroupHash(void *netSendComm, uint64_t groupHash);
+extern ncclResult_t setNcclRank(void *netSendComm, int rank);
+extern ncclNet_t* ncclNets[3];
+
 // Forward declaration
 static ncclResult_t sendProxyProgress(struct ncclProxyState* proxyState, struct ncclProxyArgs* args);
 
@@ -585,9 +593,6 @@ static ncclResult_t sendProxySetup(struct ncclProxyConnection* connection, struc
   resources->netDeviceVersion = props.netDeviceVersion;
   resources->netDeviceType = props.netDeviceType;
 
-  resources->netDeviceVersion = props.netDeviceVersion;
-  resources->netDeviceType = props.netDeviceType;
-
   // We don't return any data
   if (respSize != 0) return ncclInternalError;
   *done = 1;
@@ -683,7 +688,7 @@ static ncclResult_t sendProxyConnect(struct ncclProxyConnection* connection, str
     ret = proxyState->ncclNet->connect(resources->netDev, req->handle, &resources->netSendComm, &resources->netDeviceHandle);
     connection->proxyAppendPtr = &connection->proxyAppend;
   }
-
+  
   NCCLCHECK(ret);
   if (resources->netSendComm == NULL) {
     *done = 0;
@@ -691,6 +696,10 @@ static ncclResult_t sendProxyConnect(struct ncclProxyConnection* connection, str
   }
   *done = 1;
 
+  if(proxyState->ncclNet == &ncclNetIb)
+  NCCLCHECK(saveChannelToQp(resources->netSendComm, resources->channelId));
+
+
   if (resources->netDeviceHandle) {
     connection->netDeviceHandle = resources->netDeviceHandle;
     connection->needsProxyProgress = connection->netDeviceHandle->needsProxyProgress;
@@ -1118,6 +1127,14 @@ static ncclResult_t sendProxyProgress(struct ncclProxyState* proxyState, struct
           }
           if (ready) {
             // Data is ready, try to send.
+            if(proxyState->ncclNet == &ncclNetIb){
+              NCCLCHECK(setCommunicationAlgorithm(resources->netSendComm, args->coll));
+              NCCLCHECK(setNcclFuncTimes(resources->netSendComm, args->ncclFuncTimes));
+              NCCLCHECK(setNcclPeerRank(resources->netSendComm, args->peerRank));
+              NCCLCHECK(setNcclRank(resources->netSendComm, args->rank));
+              NCCLCHECK(setNcclGroupHash(resources->netSendComm, args->groupHash));
+            }
+            
             NCCLCHECK(proxyState->ncclNet->isend(resources->netSendComm, buff, size, resources->tpRank, sub->mhandle, sub->requests+buffSlot));
             if (sub->requests[buffSlot] != NULL) {
               TRACE(NCCL_NET, "sendProxy [%ld/%d] Isend posted, req %p, size %d, proto %d, myRank %d, channelId %d", sub->transmitted, buffSlot, sub->requests[buffSlot], size, p, proxyState->tpRank, sub->channelId);
@@ -1135,6 +1152,7 @@ static ncclResult_t sendProxyProgress(struct ncclProxyState* proxyState, struct
         int size;
         int buffSlot = (sub->base+sub->done)%NCCL_STEPS;
         NCCLCHECK(proxyState->ncclNet->test(sub->requests[buffSlot], &done, &size));
+
         if (done) {
           if (sub->reg) {
             if (size < sub->nbytes) {
@@ -1299,7 +1317,8 @@ static ncclResult_t recvProxyProgress(struct ncclProxyState* proxyState, struct
         int sizes[NCCL_PROXY_MAX_SUBS];
         void* mhandles[NCCL_PROXY_MAX_SUBS];
         for (int i=0; i<NCCL_PROXY_MAX_SUBS; i++) sizes[i] = 0;
-        NCCLCHECK(proxyState->ncclNet->test(subGroup->requests[step%NCCL_STEPS], &done, sizes));
+        NCCLCHECK(proxyState->ncclNet->test(subGroup->requests[step % NCCL_STEPS], &done, sizes));
+
         if (done) {
           int needFlush = 0;
           int totalSize = 0;
diff --git a/src/transport/net_ib.cc b/src/transport/net_ib.cc
index 551ca61..ab6fc2d 100644
--- a/src/transport/net_ib.cc
+++ b/src/transport/net_ib.cc
@@ -24,11 +24,25 @@
 #include "timer.h"
 
 #include "ibvwrap.h"
+#define NET_IB_CC
+#include "timer_log.h"
 
 #define MAXNAMESIZE 64
 static char ncclIbIfName[MAX_IF_NAME_SIZE+1];
 static union ncclSocketAddress ncclIbIfAddr;
 
+const long long second_to_nanoseconds = 1000000000;
+
+long long get_nanoseconds()
+{
+  long long ns = 0;
+  struct timespec ts;
+  clock_gettime(CLOCK_REALTIME, &ts);
+  ns += ts.tv_sec;
+  ns *= second_to_nanoseconds;
+  ns += ts.tv_nsec;
+  return ns;
+}
 struct ncclIbMr {
   uintptr_t addr;
   size_t pages;
@@ -711,6 +725,8 @@ struct ncclIbRequest {
   int events[NCCL_IB_MAX_DEVS_PER_NIC];
   struct ncclIbNetCommDevBase* devBases[NCCL_IB_MAX_DEVS_PER_NIC];
   int nreqs;
+  long long time;
+  int time_out;
   union {
     struct {
       int size;
@@ -722,6 +738,20 @@ struct ncclIbRequest {
       int* sizes;
     } recv;
   };
+  struct timer_log log[NCCL_IB_MAX_DEVS_PER_NIC];
+};
+struct ncclwarn{
+  bool is_warn=false;
+  int status;
+  int opcode;
+  int len;
+  int error;
+  std::string line;
+  std::string type;
+  std::string localGidstr;
+  std::string localGidstring;
+  std::string remoteGidstr;
+  std::string remoteGidstring;
 };
 
 struct ncclIbNetCommDevBase {
@@ -730,6 +760,7 @@ struct ncclIbNetCommDevBase {
   struct ibv_cq* cq;
   uint64_t pad[2];
   struct ncclIbGidInfo gidInfo;
+  alignas(32) struct ncclwarn warn;
 };
 
 struct ncclIbListenComm {
@@ -752,6 +783,11 @@ struct ncclIbQp {
   struct ibv_qp* qp;
   int devIndex;
   int remDevIdx;
+  uint8_t srcIp[4];
+  uint8_t dscIp[4];
+  int channel_id;
+  int rank;
+  std::string NetworkCardName="";
 };
 
 struct ncclIbRemSizesFifo {
@@ -802,6 +838,11 @@ struct ncclIbSendComm {
   struct ncclIbRemSizesFifo remSizesFifo;
   uint64_t fifoHead;
   int ar; // Use adaptive routing when all merged devices have it enabled
+  uint8_t func;
+  unsigned long long ncclFuncTimes;
+  int peerRank;
+  int rank;
+  uint64_t groupHash;
 };
 // The SendFifo needs to be 32-byte aligned and each element needs
 // to be a 32-byte multiple, so that an entry does not get split and
@@ -1019,11 +1060,12 @@ ib_connect_check:
     ncclIbDev* ibDev = ncclIbDevs + commDev->base.ibDevN;
     NCCLCHECK(ncclIbCreateQp(ibDev->portNum, &commDev->base, IBV_ACCESS_REMOTE_WRITE, comm->base.qps+q));
     comm->base.qps[q].devIndex = devIndex;
-    meta.qpInfo[q].qpn      = comm->base.qps[q].qp->qp_num;
-    meta.qpInfo[q].devIndex = comm->base.qps[q].devIndex;
+    meta.qpInfo[q].qpn       = comm->base.qps[q].qp->qp_num;
+    meta.qpInfo[q].devIndex  = comm->base.qps[q].devIndex;
 
     // Query ece capabilities (enhanced connection establishment)
     NCCLCHECK(wrap_ibv_query_ece(comm->base.qps[q].qp, &meta.qpInfo[q].ece, &meta.qpInfo[q].ece_supported));
+
     devIndex = (devIndex + 1) % comm->base.ndevs;
   }
 
@@ -1072,6 +1114,11 @@ ib_connect_check:
   meta.fifoAddr = (uint64_t)comm->fifo;
   strncpy(meta.devName, mergedDev->devName, MAX_MERGED_DEV_NAME);
 
+  for(int q = 0; q < comm->base.nqps; q++){
+    *(u_int *)comm->base.qps[q].srcIp = *(u_int*)(&comm->devs[comm->base.qps[q].devIndex].base.gidInfo.localGid.raw[12]);
+    comm->base.qps[q].NetworkCardName = meta.devName;
+  }
+
   stage->state = ncclIbCommStateSend;
   stage->offset = 0;
   NCCLCHECK(ncclIbMalloc((void**)&stage->buffer, sizeof(meta)));
@@ -1122,6 +1169,12 @@ ib_connect:
     comm->remSizesFifo.addr = remMeta.fifoAddr;
   }
 
+  for(int q = 0; q < comm->base.nqps; q++){
+    struct ncclIbQpInfo* remQpInfo   = remMeta.qpInfo + q;
+    // struct ncclIbDevInfo* remDevInfo = remMeta.devs + remQpInfo->devIndex;
+    *(u_int *)comm->base.qps[q].dscIp = *(u_int*)(&comm->base.remDevs[remQpInfo->devIndex].remoteGid.raw[12]);
+  }
+
   for (int i=0; i < comm->base.ndevs; i++) {
     NCCLCHECK(wrap_ibv_reg_mr(comm->remSizesFifo.mrs+i, comm->devs[i].base.pd, &comm->remSizesFifo.elems, sizeof(int)*MAX_REQUESTS*NCCL_NET_IB_MAX_RECVS, IBV_ACCESS_REMOTE_WRITE|IBV_ACCESS_LOCAL_WRITE|IBV_ACCESS_REMOTE_READ));
   }
@@ -1153,7 +1206,7 @@ ib_connect:
       INFO(NCCL_NET,"NET/IB: IbDev %d Port %d qpn %d set_ece={supported=%d, vendor_id=0x%x, options=0x%x, comp_mask=0x%x}",
         ibDevN, ibDev->portNum, remMeta.qpInfo[q].qpn, remMeta.qpInfo[q].ece_supported, remMeta.qpInfo[q].ece.vendor_id, remMeta.qpInfo[q].ece.options, remMeta.qpInfo[q].ece.comp_mask);
     }
-  }
+  } 
 
   comm->base.ready = 1;
   stage->state = ncclIbCommStateConnected;
@@ -1312,6 +1365,10 @@ ib_recv:
       devInfo.mtu         = ibDev->portAttr.active_mtu;
       NCCLCHECK(ncclIbRtrQp(rCommDev->gpuFlush.qp.qp, rCommDev->base.gidInfo.localGidIndex, rCommDev->gpuFlush.qp.qp->qp_num, &devInfo));
       NCCLCHECK(ncclIbRtsQp(rCommDev->gpuFlush.qp.qp));
+
+      *(u_int*)rCommDev->gpuFlush.qp.srcIp = *(u_int*)(&rCommDev->base.gidInfo.localGid.raw[12]);
+      *(u_int*)rCommDev->gpuFlush.qp.dscIp = *(u_int*)(&rCommDev->base.gidInfo.localGid.raw[12]);
+
     }
 
     // Fill Handle
@@ -1345,6 +1402,16 @@ ib_recv:
   NCCLCHECK(ncclIbMalloc((void**)&stage->buffer, sizeof(struct ncclIbConnectionMetadata)));
   memcpy(stage->buffer, &meta, sizeof(struct ncclIbConnectionMetadata));
 
+
+  for(int q = 0; q < rComm->base.nqps; q++){
+    *(u_int *)rComm->base.qps[q].srcIp = *(u_int*)(&rComm->devs[rComm->base.qps[q].devIndex].base.gidInfo.localGid.raw[12]);
+  }
+  for(int q = 0; q < rComm->base.nqps; q++){
+    struct ncclIbQpInfo* remQpInfo   = remMeta.qpInfo + q;
+    // struct ncclIbDevInfo* remDevInfo = remMeta.devs + remQpInfo->devIndex;
+    *(u_int *)rComm->base.qps[q].dscIp = *(u_int*)(&rComm->base.remDevs[remQpInfo->devIndex].remoteGid.raw[12]);
+  }
+
 ib_send:
   NCCLCHECK(ncclSocketProgress(NCCL_SOCKET_SEND, &rComm->base.sock, stage->buffer, sizeof(struct ncclIbConnectionMetadata), &stage->offset));
   if (stage->offset < sizeof(struct ncclIbConnectionMetadata)) return ncclSuccess;
@@ -1376,6 +1443,8 @@ ncclResult_t ncclIbGetRequest(struct ncclIbNetCommBase* base, struct ncclIbReque
       r->devBases[0] = NULL;
       r->devBases[1] = NULL;
       r->events[0] = r->events[1] = 0;
+      r->time = get_nanoseconds();
+      r->time_out = 0;
       *req = r;
       return ncclSuccess;
     }
@@ -1387,6 +1456,8 @@ ncclResult_t ncclIbGetRequest(struct ncclIbNetCommBase* base, struct ncclIbReque
 
 ncclResult_t ncclIbFreeRequest(struct ncclIbRequest* r) {
   r->type = NCCL_NET_IB_REQ_UNUSED;
+  r->time = 0;
+  r->time_out = 0;
   return ncclSuccess;
 }
 
@@ -1513,6 +1584,10 @@ ncclResult_t ncclIbDeregMr(void* comm, void* mhandle) {
 
 NCCL_PARAM(IbSplitDataOnQps, "IB_SPLIT_DATA_ON_QPS", 0);
 
+// count the number of send wrs and remain data sizes in wrs
+thread_local int sendWrCounter[NCCL_IB_MAX_DEVS_PER_NIC] = {0};
+thread_local int remainWrDataSize[NCCL_IB_MAX_DEVS_PER_NIC] = {0};
+
 ncclResult_t ncclIbMultiSend(struct ncclIbSendComm* comm, int slot) {
   struct ncclIbRequest** reqs = comm->fifoReqs[slot];
   volatile struct ncclIbSendFifo* slots = comm->fifo[slot];
@@ -1568,15 +1643,33 @@ ncclResult_t ncclIbMultiSend(struct ncclIbSendComm* comm, int slot) {
   // Multi-QP: make sure IB writes are multiples of 128B so that LL and LL128 protocols still work
   const int align = 128;
   int nqps = ncclParamIbSplitDataOnQps() ? comm->base.nqps : comm->base.ndevs;
+
+  for(int r = 0; r < nreqs; r++){
+    for(int q = 0; q < comm->base.ndevs;q++) {
+      if(global_timer_log.collect){
+        reqs[r]->log[q].loged_start = NCCL_LOG_TELEMETRY;
+        clock_gettime(CLOCK_REALTIME, &reqs[r]->log[q].send_start);
+        // reqs[r]->log[q].size = reqs[r]->send.size;
+        reqs[r]->log[q].size = 0;
+      }
+      else reqs[r]->log[q].loged_start = NCCL_LOG_NOT_USE;
+    }
+  }
+  
   for (int i = 0; i < nqps; i++) {
     int qpIndex = comm->base.qpIndex;
     ncclIbQp* qp = comm->base.qps + qpIndex;
     int devIndex = qp->devIndex;
+
     for (int r=0; r<nreqs; r++) {
       // Track this event for completion
       //ncclIbAddEvent(reqs[r], devIndex, &comm->devs[devIndex].base);
 
       // Select proper rkey (needed even for 0-size send)
+
+      // update sendWrCounter
+      sendWrCounter[devIndex]++;
+
       comm->wrs[r].wr.rdma.rkey = slots[r].rkeys[qp->remDevIdx];
 
       int chunkSize = DIVUP(DIVUP(reqs[r]->send.size, nqps), align) * align;
@@ -1591,6 +1684,14 @@ ncclResult_t ncclIbMultiSend(struct ncclIbSendComm* comm, int slot) {
         comm->wrs[r].sg_list = comm->sges+r;
         comm->wrs[r].num_sge = 1;
       }
+      reqs[r]->log[devIndex].sendWrCounter = sendWrCounter[devIndex];
+      if(length > 0)  reqs[r]->log[devIndex].size += length;
+
+      //update remainWrDataSize
+      if (length > 0) {
+        remainWrDataSize[devIndex] += length;
+      }
+      reqs[r]->log[devIndex].remainWrDataSize = remainWrDataSize[devIndex];
     }
 
     if (nreqs > 1) {
@@ -1600,6 +1701,7 @@ ncclResult_t ncclIbMultiSend(struct ncclIbSendComm* comm, int slot) {
     }
 
     struct ibv_send_wr* bad_wr;
+
     NCCLCHECK(wrap_ibv_post_send(qp->qp, comm->wrs, &bad_wr));
 
     for (int r=0; r<nreqs; r++) {
@@ -1666,8 +1768,24 @@ ncclResult_t ncclIbIsend(void* sendComm, void* data, int size, int tag, void* mh
     // Count down
     while (nEvents > 0) {
       ncclIbQp* qp = comm->base.qps + qpIndex;
+      
+      //bool if_backup = false;
       int devIndex = qp->devIndex;
+
+      // add event
       ncclIbAddEvent(req, devIndex, &comm->devs[devIndex].base);
+
+      *(u_int *)req->log[devIndex].srcIp = *(u_int *)qp->srcIp;
+      *(u_int *)req->log[devIndex].dscIp = *(u_int *)qp->dscIp;
+      req->log[devIndex].channel_id = qp->channel_id;
+      req->log[devIndex].rank = comm->rank;
+      req->log[devIndex].func = comm->func;
+      req->log[devIndex].ncclFuncTimes = comm->ncclFuncTimes;
+      req->log[devIndex].peerRank = comm->peerRank;
+      req->log[devIndex].groupHash = comm->groupHash;
+      
+      req->log[devIndex].NetworkCardName = qp->NetworkCardName;
+      //INFO(NCCL_INIT,"-req->log[devIndex].NetworkCardName:%s-",req->log[devIndex].NetworkCardName.c_str());
       // Track the valid lkey for this RDMA_Write
       req->send.lkeys[devIndex] = mhandleWrapper->mrs[devIndex]->lkey;
       nEvents--;
@@ -1721,8 +1839,9 @@ ncclResult_t ncclIbPostFifo(struct ncclIbRecvComm* comm, int n, void** data, int
     struct ncclIbMrHandle* mhandleWrapper = (struct ncclIbMrHandle*) mhandles[i];
 
     // Send all applicable rkeys
-    for (int j = 0; j < comm->base.ndevs; j++)
+    for (int j = 0; j < comm->base.ndevs; j++) {
       localElem[i].rkeys[j] = mhandleWrapper->mrs[j]->rkey;
+    }
 
     localElem[i].nreqs = n;
     localElem[i].size = sizes[i]; // Sanity/Debugging
@@ -1735,9 +1854,10 @@ ncclResult_t ncclIbPostFifo(struct ncclIbRecvComm* comm, int n, void** data, int
   wr.wr.rdma.rkey = comm->base.remDevs[ctsQp->remDevIdx].fifoRkey;
 
   // Set the correct sge properties
-  comm->devs[ctsQp->devIndex].fifoSge.addr   = (uint64_t)localElem;
-  comm->devs[ctsQp->devIndex].fifoSge.length = n*sizeof(struct ncclIbSendFifo);
+  comm->devs[ctsQp->devIndex].fifoSge.addr = (uint64_t)localElem;
+  comm->devs[ctsQp->devIndex].fifoSge.length = n * sizeof(struct ncclIbSendFifo);
   wr.sg_list = &comm->devs[ctsQp->devIndex].fifoSge;
+  
   wr.num_sge = 1;
 
   wr.opcode = IBV_WR_RDMA_WRITE;
@@ -1770,6 +1890,23 @@ ncclResult_t ncclIbPostFifo(struct ncclIbRecvComm* comm, int n, void** data, int
     wr.send_flags |= IBV_SEND_SIGNALED;
     wr.wr_id = req - comm->base.reqs;
     ncclIbAddEvent(req, ctsQp->devIndex, &comm->devs[ctsQp->devIndex].base);
+  
+    
+    *(u_int *)req->log[ctsQp->devIndex].srcIp = *(u_int *)ctsQp->srcIp; 
+    *(u_int *)req->log[ctsQp->devIndex].dscIp = *(u_int *)ctsQp->dscIp; 
+
+
+    if(global_timer_log.collect){
+      req->log[ctsQp->devIndex].loged_start = NCCL_LOG_TELEMETRY;
+      req->log[ctsQp->devIndex].size = n*sizeof(struct ncclIbSendFifo);
+      clock_gettime(CLOCK_REALTIME, &req->log[ctsQp->devIndex].send_start);
+    }
+    else {
+      req->log[ctsQp->devIndex].loged_start = NCCL_LOG_NOT_USE;
+    }
+  }
+  else {
+    req->log[ctsQp->devIndex].loged_start = NCCL_LOG_NOT_USE;
   }
 
   struct ibv_send_wr* bad_wr;
@@ -1810,6 +1947,16 @@ ncclResult_t ncclIbIrecv(void* recvComm, int n, void** data, int* sizes, int* ta
   for (int i = 0; i < nqps; i++) {
     struct ncclIbQp* qp = comm->base.qps + comm->base.qpIndex;
     ncclIbAddEvent(req, qp->devIndex, &comm->devs[qp->devIndex].base);
+    
+    *(u_int *)req->log[qp->devIndex].srcIp = *(u_int *)qp->srcIp;
+    *(u_int *)req->log[qp->devIndex].dscIp = *(u_int *)qp->dscIp;
+    if(global_timer_log.collect){
+      clock_gettime(CLOCK_REALTIME, &req->log[qp->devIndex].send_start);
+      req->log[qp->devIndex].loged_start = NCCL_LOG_TELEMETRY;
+    }
+    else req->log[qp->devIndex].loged_start = NCCL_LOG_NOT_USE;
+
+
     NCCLCHECK(wrap_ibv_post_recv(qp->qp, &wr, &bad_wr));
     comm->base.qpIndex = (comm->base.qpIndex+1)%comm->base.nqps;
   }
@@ -1851,6 +1998,18 @@ ncclResult_t ncclIbIflush(void* recvComm, int n, void** data, int* sizes, void**
     wr.opcode = IBV_WR_RDMA_READ;
     wr.send_flags = IBV_SEND_SIGNALED;
 
+    *(u_int *)req->log[comm->devs[i].gpuFlush.qp.devIndex].srcIp = *(u_int *)comm->devs[i].gpuFlush.qp.srcIp;
+    *(u_int *)req->log[comm->devs[i].gpuFlush.qp.devIndex].dscIp = *(u_int *)comm->devs[i].gpuFlush.qp.dscIp;
+    if (global_timer_log.collect)
+    {
+      req->log[comm->devs[i].gpuFlush.qp.devIndex].loged_start = NCCL_LOG_TELEMETRY;
+
+      clock_gettime(CLOCK_REALTIME, &req->log[comm->devs[i].gpuFlush.qp.devIndex].send_start);
+      // req->log[comm->devs[i].gpuFlush.qp.devIndex].size = 0;
+    }
+    else
+      req->log[comm->devs[i].gpuFlush.qp.devIndex].loged_start = NCCL_LOG_NOT_USE;
+
     TIME_START(4);
     struct ibv_send_wr* bad_wr;
     NCCLCHECK(wrap_ibv_post_send(comm->devs[i].gpuFlush.qp.qp, &wr, &bad_wr));
@@ -1922,6 +2081,9 @@ ncclResult_t ncclIbTest(void* request, int* done, int* sizes) {
               ncclSocketToString(&addr, line), wc->status, wc->opcode,wc->byte_len, wc->wr_id, req, req->type, req->events[0], req->events[1], i);
           #endif
           if (req->type == NCCL_NET_IB_REQ_SEND) {
+            // update sendWrCounter
+            sendWrCounter[i] -= req->nreqs;
+
             for (int j = 0; j < req->nreqs; j++) {
               struct ncclIbRequest* sendReq = r->base->reqs+((wc->wr_id >> (j*8)) & 0xff);
               if ((sendReq->events[i] <= 0)) {
@@ -1929,6 +2091,24 @@ ncclResult_t ncclIbTest(void* request, int* done, int* sizes) {
                 return ncclInternalError;
               }
               sendReq->events[i]--;
+              if(global_timer_log.collect && sendReq->log[i].loged_start == NCCL_LOG_TELEMETRY && !sendReq->events[i]){
+                clock_gettime(CLOCK_REALTIME, &sendReq->log[i].send_end);
+                sendReq->log[i].diff = 1000000000L * (sendReq->log[i].send_end.tv_sec) + sendReq->log[i].send_end.tv_nsec;
+                sendReq->log[i].sendWrCounter = sendWrCounter[i];
+                sendReq->log[i].devIndex = i;
+
+                //sendReq has completed transport, update remainWrDataSize
+                remainWrDataSize[i] -= sendReq->log[i].size;
+                sendReq->log[i].remainWrDataSize = remainWrDataSize[i];
+
+                if(sendReq->log[i].size > 16){
+                  // save log
+                  pthread_mutex_lock(&global_timer_log.lock);
+                  __sync_synchronize();
+                  global_timer_log.push(sendReq->log[i]);
+                  pthread_mutex_unlock(&global_timer_log.lock);
+                }
+              }
             }
           } else {
             if (req && wc->opcode == IBV_WC_RECV_RDMA_WITH_IMM) {
@@ -1947,7 +2127,9 @@ ncclResult_t ncclIbTest(void* request, int* done, int* sizes) {
     }
 
     // If no CQEs found on any device, return and come back later
-    if (totalWrDone == 0) return ncclSuccess;
+    if (totalWrDone == 0) {
+      return ncclSuccess;
+    }
   }
 }
 
@@ -1956,8 +2138,10 @@ ncclResult_t ncclIbCloseSend(void* sendComm) {
   if (comm) {
     NCCLCHECK(ncclSocketClose(&comm->base.sock));
 
-    for (int q = 0; q < comm->base.nqps; q++)
-      if (comm->base.qps[q].qp != NULL) NCCLCHECK(wrap_ibv_destroy_qp(comm->base.qps[q].qp));
+    for (int q = 0; q < comm->base.nqps; q++) {
+      if (comm->base.qps[q].qp != NULL)
+        NCCLCHECK(wrap_ibv_destroy_qp(comm->base.qps[q].qp));
+    }     
 
     for (int i = 0; i < comm->base.ndevs; i++) {
       struct ncclIbSendCommDev* commDev = comm->devs + i;
@@ -1976,8 +2160,10 @@ ncclResult_t ncclIbCloseRecv(void* recvComm) {
   if (comm) {
     NCCLCHECK(ncclSocketClose(&comm->base.sock));
 
-    for (int q = 0; q < comm->base.nqps; q++)
-      if (comm->base.qps[q].qp != NULL) NCCLCHECK(wrap_ibv_destroy_qp(comm->base.qps[q].qp));
+    for (int q = 0; q < comm->base.nqps; q++) {
+      if (comm->base.qps[q].qp != NULL)
+        NCCLCHECK(wrap_ibv_destroy_qp(comm->base.qps[q].qp));
+    }  
 
     for (int i = 0; i < comm->base.ndevs; i++) {
       struct ncclIbRecvCommDev* commDev = comm->devs + i;
@@ -2003,6 +2189,46 @@ ncclResult_t ncclIbCloseListen(void* listenComm) {
   return ncclSuccess;
 }
 
+ncclResult_t saveChannelToQp(void* netSendComm, int channel_id){
+  struct ncclIbSendComm* comm = (struct ncclIbSendComm*)netSendComm;
+  for(int q = 0; q < comm->base.nqps; q++){
+    comm->base.qps[q].channel_id = channel_id;
+    //comm->base.backupQps[q].channel_id = channel_id;
+  }
+  return ncclSuccess;
+}
+
+ncclResult_t setCommunicationAlgorithm(void *netSendComm, uint8_t func){
+  struct ncclIbSendComm* comm = (struct ncclIbSendComm*)netSendComm;
+  comm->func = func;
+  return ncclSuccess;
+}
+
+ncclResult_t setNcclFuncTimes(void *netSendComm, unsigned long long ncclFuncTimes){
+  struct ncclIbSendComm* comm = (struct ncclIbSendComm*)netSendComm;
+  comm->ncclFuncTimes = ncclFuncTimes;
+  return ncclSuccess;
+}
+
+ncclResult_t setNcclPeerRank(void *netSendComm, int rank){
+  struct ncclIbSendComm* comm = (struct ncclIbSendComm*)netSendComm;
+  comm->peerRank = rank;
+  return ncclSuccess;
+}
+
+ncclResult_t setNcclRank(void *netSendComm, int rank){
+  struct ncclIbSendComm* comm = (struct ncclIbSendComm*)netSendComm;
+  comm->rank = rank;
+  return ncclSuccess;
+}
+
+ncclResult_t setNcclGroupHash(void *netSendComm, uint64_t groupHash){
+  struct ncclIbSendComm* comm = (struct ncclIbSendComm*)netSendComm;
+  comm->groupHash = groupHash;
+  return ncclSuccess;
+}
+
+
 ncclNet_t ncclNetIb = {
   "IB",
   ncclIbInit,
diff --git a/src/transport/ring_log.cc b/src/transport/ring_log.cc
new file mode 100644
index 0000000..f86a287
--- /dev/null
+++ b/src/transport/ring_log.cc
@@ -0,0 +1,151 @@
+#include "nccl.h"
+#include "ring_log.h"
+#include "core.h"
+#include <sys/un.h>
+#include <iostream>
+#include <fstream>
+#include <string>
+#include <ctime>
+#include <iomanip>
+#include <sstream>
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <chrono>
+
+const int nccl_megatrace_enable = ncclGetEnv("NCCL_MEGATRACE_ENABLE") ? atoi(ncclGetEnv("NCCL_MEGATRACE_ENABLE")) : 0;
+const char* nccl_megatrace_log_path = ncclGetEnv("NCCL_MEGATRACE_ENABLE")?ncclGetEnv("NCCL_MEGATRACE_LOG_PATH"):"./logs";
+const int nccl_sensitive_time = ncclGetEnv("NCCL_MEGATRACE_SENSTIME") ? atoi(ncclGetEnv("NCCL_MEGATRACE_SENSTIME")) : 3000;
+
+
+int64_t current_time_in_ms() {
+    struct timespec now;
+    clock_gettime(CLOCK_REALTIME, &now);  //  
+
+   
+    return now.tv_sec * 1000 + now.tv_nsec / 1000000;
+}
+
+
+void ring_buffer_init(ring_buffer_t *rb) {
+    rb->head.store(0);
+    rb->tail.store(0);
+    ring_nccl_log.live = 1 ;
+
+}
+
+int ring_buffer_count(ring_buffer_t *rb) {
+    int tail = rb->tail.load(std::memory_order_acquire);
+    int head = rb->head.load(std::memory_order_acquire);
+    if (head >= tail) {
+        return head - tail;
+    } else {
+        return RING_BUFFER_SIZE - tail + head;
+    }
+}
+
+
+int ring_buffer_push(ring_buffer_t *rb, const char *msg) {
+    int head = rb->head.load(std::memory_order_relaxed);
+    int next_head = (head + 1) % RING_BUFFER_SIZE;
+    int tail = rb->tail.load(std::memory_order_acquire);
+    if (next_head == tail) {         // 缓冲区满
+        tail = (tail + 1) % RING_BUFFER_SIZE;
+    }
+    std::string msg_str(msg);  // 将 msg 转换为 std::string
+    if (msg_str.length() < LOG_MAX_LEN) {
+        std::strcpy(rb->buffer[head].msg, msg_str.c_str());
+    } else {
+        std::strncpy(rb->buffer[head].msg, msg_str.c_str(), LOG_MAX_LEN - 1);
+        rb->buffer[head].msg[LOG_MAX_LEN - 1] = '\0';  // 确保终止符
+    }
+    rb->last_write_ts.store(current_time_in_ms());
+    rb->head.store(next_head,std::memory_order_release);
+    rb->tail.store(tail, std::memory_order_release);
+    return 0;
+}
+
+int ring_buffer_pop_batch(ring_buffer_t *rb, log_entry_t *out_entries, int max_entries) {
+    int tail = rb->tail.load(std::memory_order_relaxed);
+    int head = rb->head.load(std::memory_order_acquire);
+    int count;
+         if (head >= tail) {
+             count = head - tail;
+         } else {
+             count = RING_BUFFER_SIZE - tail + head;
+         }
+         if (count > max_entries) {
+             count = max_entries;
+         }
+         for (int i = 0; i < count; i++) {
+             int index = (tail + i) % RING_BUFFER_SIZE;
+             out_entries[i] = rb->buffer[index];
+         }
+         rb->tail.store((tail + count) % RING_BUFFER_SIZE,std::memory_order_release);
+    	 return count;
+}
+
+
+ 
+void *log_writer_thread(void *arg) {
+    const char *rank_str = getenv("OMPI_COMM_WORLD_RANK");
+    if (rank_str == NULL) {
+        fprintf(stderr, "Error: Environment variable 'OMPI_COMM_RANK' not found.\n");
+        return NULL;
+    }
+    int rank = atoi(rank_str); // 将 rank 从字符串转换为整数
+    // 定义文件路径
+    char filename[256];
+    snprintf(filename, sizeof(filename), "%s/rank_%d.log", nccl_megatrace_log_path, rank);
+
+    // 打开文件
+    FILE *fp = fopen(filename, "w");
+    if (!fp) {
+        perror("[Megatrace] open file error,file path not exist.\n");
+        return NULL;
+    }
+    if(rank == 0){ 
+	 INFO(NCCL_INIT,"[Megatrace] start log thread.\n");
+    }
+    log_entry_t logs[BATCH_SIZE];
+    int save_iter=0;
+    while (1) {
+        int64_t now = current_time_in_ms();
+        int64_t last = ring_nccl_log.last_write_ts.load();
+        int64_t time_diff = now - last;
+        int num_logs = ring_buffer_count(&ring_nccl_log);   
+	    if (time_diff < nccl_sensitive_time || num_logs == 0) {       
+            INFO(NCCL_INIT,"time_diff: %ld  num_logs: %d\n",time_diff,num_logs);
+            sleep(1);  
+        } else {            
+                 save_iter++;
+                 INFO(NCCL_INIT,"[save %d] save %d logs\n",save_iter,num_logs);
+                 int n_logs = ring_buffer_pop_batch(&ring_nccl_log, logs, num_logs);
+                 for (int i = 0; i < n_logs; i++) {
+                    fprintf(fp, "[save_count %d] %s\n", save_iter,logs[i].msg);
+                 }
+                 fflush(fp);
+                 sleep(1); 
+        }
+    }
+    fclose(fp);
+    return NULL;
+}
+
+void log_event(struct timespec time_api, size_t count, const char* opName, cudaStream_t stream,int64_t opCount,int64_t groupHash) {
+    //log_event(time_api, info->count, info->opName, info->stream, info->comm->opCount,info->count,info->comm,);
+    // 用于格式化日志信息
+    char log_msg[LOG_MAX_LEN];
+
+    // 获取当前时间戳字符串（格式化为秒.纳秒的形式）
+    char time_str[64];
+    snprintf(time_str, sizeof(time_str), "%ld.%09ld", time_api.tv_sec, time_api.tv_nsec);
+    const char *rank_str = getenv("OMPI_COMM_WORLD_RANK");
+    int rank = atoi(rank_str);
+    // 格式化日志内容
+    snprintf(log_msg, sizeof(log_msg), "[%s] [Rank %d] Fun %s Data %zu stream %p opCount %ld groupHash %ld",
+             time_str,rank ,opName, count, (void*)stream,opCount,groupHash);
+    //int num = ring_buffer_count(&ring_nccl_log);
+    // 将格式化后的日志写入环形缓冲区
+    ring_buffer_push(&ring_nccl_log, log_msg);
+}
diff --git a/src/transport/timer_log.cc b/src/transport/timer_log.cc
new file mode 100644
index 0000000..130c83a
--- /dev/null
+++ b/src/transport/timer_log.cc
@@ -0,0 +1,140 @@
+#include "timer_log.h"
+#include "nccl.h"
+#include "core.h"
+#include <sys/un.h>
+#include <iostream>
+#include <fstream>
+#include <string>
+#include <ctime>
+#include <iomanip>
+#include <sstream>
+#include <map>
+#include <chrono>
+
+const int nccl_telemetry_enable = ncclGetEnv("NCCL_TELEMETRY_ENABLE") ? atoi(ncclGetEnv("NCCL_TELEMETRY_ENABLE")) : 0;
+const char* nccl_telemetry_log_path = ncclGetEnv("NCCL_TELEMETRY_LOG_PATH");
+using Clock = std::chrono::steady_clock;
+
+std::string getCurrentTimeString() {
+    std::time_t now = std::time(nullptr);
+    std::tm* localTime = std::localtime(&now);
+
+    std::ostringstream oss;
+    oss << std::put_time(localTime, "%Y%m%d%H%M%S");
+    return oss.str();
+}
+
+void printLogInfo(struct timer_log log){
+  INFO(NCCL_NET, "%d.%d.%d.%d->%d.%d.%d.%d send %d Bits used %lld nsec", 
+             log.srcIp[0],log.srcIp[1],log.srcIp[2],log.srcIp[3],
+             log.dscIp[0],log.dscIp[1],log.dscIp[2],log.dscIp[3],
+             log.size,log.diff
+  );
+}
+
+struct PortLogs {
+  std::ofstream files[2];                 // 两个日志文件
+  int currentFile = 0;                    // 当前活动的文件索引（0或1）
+  bool headerWritten[2] = {false, false}; // 是否已写入标题行
+  std::string filenames[2];               // 两个文件的路径
+  Clock::time_point            startTime[2];
+};
+std::map<std::string, std::map<int, PortLogs>> logFilesMap; // 网卡名 -> 端口 -> 日志文件
+
+void* timerLogService(void *args){
+  // signal(SIGPIPE, sigpipe_handler);
+  //setupTelemetry();//set up environment variables
+  struct sockaddr_un server_addr;
+  memset(&server_addr, 0, sizeof(server_addr));
+  server_addr.sun_family = AF_UNIX;
+  strncpy(server_addr.sun_path, SOCK_PATH, sizeof(server_addr.sun_path) - 1);
+  //WARN("------------NCCL_TELEMETRY_ENABLE = %d-------------", nccl_telemetry_enable);
+
+  if(TIMER_LOG_NCCL_TELEMETRY){
+    static std::map<std::string, std::map<int, PortLogs>> logFilesMap; // new
+
+    //std::string baseName = global_timer_log.log[i].NetworkCardName;
+    std::string timestamp = getCurrentTimeString();
+
+    while(!global_timer_log.stop){
+      global_timer_log.collect = 1;
+
+      __sync_synchronize();
+      if(!global_timer_log.log.empty()){
+
+        pthread_mutex_lock(&global_timer_log.lock);
+        __sync_synchronize();
+        if(global_timer_log.log.empty()){
+          pthread_mutex_unlock(&global_timer_log.lock);
+          continue;
+        }
+        timer_log log = global_timer_log.pop();
+        
+        // update slide window
+        global_timer_log.pushSlideWindow(log, log.devIndex);
+        pthread_mutex_unlock(&global_timer_log.lock);
+        if (global_timer_log.slideWindow[log.devIndex].size() < maxWindowSize) {
+          continue;
+        }
+        
+        std::string ncName = log.NetworkCardName;
+        auto& nicMap = logFilesMap[ncName];
+        if (!nicMap.count(log.devIndex)) {
+          auto& portLogs = nicMap[log.devIndex];
+          char hostname[1024];
+          getHostName(hostname, 1024, '.');
+          for (int i = 0; i < 2; i++) {
+            std::string filename = std::string(nccl_telemetry_log_path) + "/" +
+                                   hostname + "_" + ncName + "_Port" + std::to_string(log.devIndex)+
+                                   (i == 0 ? "_A.log" : "_B.log");
+            portLogs.filenames[i] = filename;
+            portLogs.files[i].open(filename, std::ios::trunc);
+            portLogs.files[i] << "Time,Group,FromRank,ToRank,DevIndex,Func,FuncTimes,SrcIP,DstIP,Bandwidth,SendWrCounter,RemainWrDataSize,Timestamp\n";
+            portLogs.headerWritten[i] = true;
+            // portLogs.startTime[i] = Clock::now();
+          }
+          portLogs.currentFile = 0; // 初始化当前文件索引
+        }
+        PortLogs& portLogs = nicMap[log.devIndex];
+        std::ofstream* pFile = &portLogs.files[portLogs.currentFile];
+
+        // static bool first10MBPrinted[2] = {false, false};
+        if (static_cast<size_t>(pFile->tellp()) >= 10 * 1024 * 1024) {
+          // long long nsec = std::chrono::duration_cast<std::chrono::nanoseconds>(
+          //   Clock::now() - portLogs.startTime[portLogs.currentFile]).count();
+
+          // if (!first10MBPrinted[log.devIndex]) {
+          //   printf("[NCCL][Telemetry] %s first reached 10MiB in %.3f s (%lld ns)\n",
+          //           portLogs.filenames[portLogs.currentFile].c_str(), nsec / 1e9, nsec);
+          //   first10MBPrinted[log.devIndex] = true;
+          // }
+          pFile->close();
+          portLogs.currentFile ^= 1;
+          pFile = &portLogs.files[portLogs.currentFile];
+          
+          pFile->open(portLogs.filenames[portLogs.currentFile], std::ios::trunc);
+          *pFile << "Time,Group,FromRank,ToRank,DevIndex,Func,FuncTimes,SrcIP,DstIP,Bandwidth,SendWrCounter,RemainWrDataSize,Timestamp\n";
+          portLogs.headerWritten[portLogs.currentFile] = true;
+          // 为下一次轮转重新记起点
+          // portLogs.startTime[portLogs.currentFile] = Clock::now();
+        }
+        int bandWidths = global_timer_log.getBandWidths(log.devIndex);
+        char dataBuffer[512];
+        sprintf(dataBuffer, "%s,%lu,%d,%d,%d,%u,%lld,%d.%d.%d.%d,%d.%d.%d.%d,%d,%d,%d,%lld",
+                getCurrentTimeString().c_str(), log.groupHash, log.rank, log.peerRank, log.devIndex,
+                log.func, log.ncclFuncTimes,
+                log.srcIp[0], log.srcIp[1], log.srcIp[2], log.srcIp[3],
+                log.dscIp[0], log.dscIp[1], log.dscIp[2], log.dscIp[3],
+                bandWidths, log.sendWrCounter, log.remainWrDataSize, log.diff);
+        (*pFile) << dataBuffer << std::endl;
+      }
+    }
+    for (auto& nic : logFilesMap) {
+      for (auto& port : nic.second) {
+          port.second.files[0].close();
+          port.second.files[1].close();
+      }
+    }
+  }
+  return 0;
+}
\ No newline at end of file
